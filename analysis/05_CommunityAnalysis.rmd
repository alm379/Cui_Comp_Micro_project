---
title: "05_CommunityAnalysis.Rmd"
author: "Andrea Martinez"
date: "`r Sys.Date()`"
output:
  html_document: 
    code_folding: show
    theme: spacelab
    highlight: pygments
    keep_md: no
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
      toc_depth: 3
  keep_md: true  
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.path = "../figures/05_CommunityAnalysis")
```

# Goals 

1. Load in phyloseq data with rooted tree.  
2. Evaluate sequencing depth and remove sample.  
3. Normalize the read counts between samples.  
4. Calculate community dissimilarities. Numbers between 0 and 1. If 0, completely similar versus if they are 1, then they're completely dissimilar.   
    a. **Sorensen**: Shared Species as a binary value: Abundance-unweighted 
    b. **Bray-Curtis**: Shared Abundant species: Abundance-weighted
    c. **(Abundance-)Weighted UNIFRAC**: Consider Abundant Species and where they fall on the tree  
5. Visualize the community data with two unconstrained Ordinations:  
    a. **PCoA**: Linear Method. Eigenvalue = how much variation is explained by each axis. Choose to view axis 1, 2, 3, etc. and plot them together.  
    b. **NMDS**: Non-linear. Smush multiple Dimensions into 2 or 3 axes. Need to report Stress value (ideally <0.15).  
6. Run statistics with PERMANOVA and betadispR. 

# Setup 

## Set the seed 
```{r set-seed}
# Any number can be chosen 
set.seed(238428)
```

## Load Libraries
```{r load-libraries}
#install.packages("vegan")
pacman::p_load(tidyverse, devtools, phyloseq, patchwork, vegan,
               install = FALSE)

# Load colors 
n_colors <- c(
  "0" = "#D9CC3C",
  "150" = "#A0E0BA",
  "300" = "coral2")
  
growth_stage_colors <- c (
  "30" = "lightblue",
  "75" = "darkblue")

planted_colors <- c (
  "Unplanted" = "springgreen",
  "Planted" = "purple")
```

## Load Data 
```{r load-physeq}
# Load in rooted phylogenetic tree! 
load("data/03_Phylogenetic_Tree/phytree_preprocessed_physeq.RData")
midroot_physeq_rm18392
unrooted_physeq_rm18392
```

# Explore Read Counts 

## Raw read depth 
```{r calc-seq-depth}
# Calculate the total number of reads per sample. 
raw_TotalSeqs_df <- 
  midroot_physeq_rm18392 %>%
  # calculate the sample read sums 
  sample_sums() %>%
  data.frame()
# name the column 
colnames(raw_TotalSeqs_df)[1] <- "TotalSeqs"
  
head(raw_TotalSeqs_df)

# make histogram of raw reads 
raw_TotalSeqs_df %>%
  ggplot(aes(x = TotalSeqs)) + 
  geom_histogram(bins = 50 ) + 
  scale_x_continuous(limits = c(0, 30000)) + 
  labs(title = "Raw Sequencing Depth Distribution") + 
  theme_classic()
```

## Remove lowly seq sample 
```{r low-seq-sample}
raw_rooted_physeq <- 
  midroot_physeq_rm18392 %>%
  # remove lowly seq sample that was outlier in alpha diversity analysis
  subset_samples(names != "SRR21916204") %>%
  # any asvs unique to this sample will also be removed 
  prune_taxa(taxa_sums(.) > 0, .)

# Inspect 
raw_rooted_physeq

# what is the minimum number of sequences 
raw_rooted_physeq %>%
  sample_sums() %>%
  min()
```
## Normalize read counts  
```{r scale-reads}
### scale_reads function
#################################################################################### 
# Function to scale reads: http://deneflab.github.io/MicrobeMiseq/ 
# Scales reads by 
# 1) taking proportions
# 2) multiplying by a given library size of n
# 3) rounding 
# Default for n is the minimum sample size in your library
# Default for round is floor

matround <- function(x){trunc(x+0.5)}

scale_reads <- function(physeq, n = min(sample_sums(physeq)), round = "round") {
  
  # transform counts to n
  physeq.scale <- transform_sample_counts(physeq, function(x) {(n * x/sum(x))})
  
  # Pick the rounding functions
  if (round == "floor"){
    otu_table(physeq.scale) <- floor(otu_table(physeq.scale))
  } else if (round == "round"){
    otu_table(physeq.scale) <- round(otu_table(physeq.scale))
  } else if (round == "matround"){
    otu_table(physeq.scale) <- matround(otu_table(physeq.scale))
  }
  
  # Prune taxa and return new phyloseq object
  physeq.scale <- prune_taxa(taxa_sums(physeq.scale) > 0, physeq.scale)
  return(physeq.scale)
}
```

## Scale the reads and check the distribution of the seq depth 

This is where one might decide use rarefaction to normalize data. 
```{r scale-physeq}
min(sample_sums(raw_rooted_physeq))

# Scale reads by the above function
scaled_rooted_physeq <- 
  raw_rooted_physeq %>%
  scale_reads(round = "matround")

# Calculate the read depth 
scaled_TotalSeqs_df <- 
  scaled_rooted_physeq %>%
  sample_sums() %>%
  data.frame()
colnames(scaled_TotalSeqs_df)[1] <-"TotalSeqs"

# Inspect
head(scaled_TotalSeqs_df)

# Check the range of the data 
min_seqs <- min(scaled_TotalSeqs_df$TotalSeqs); min_seqs
max_seqs <- max(scaled_TotalSeqs_df$TotalSeqs); max_seqs
# range
max_seqs - min_seqs

# Plot Histogram 
scaled_TotalSeqs_df %>%
  ggplot(aes(x = TotalSeqs)) + 
  geom_histogram(bins = 50) + 
  scale_x_continuous(limits = c(0, 30000)) + 
  labs(title = "Scaled Sequencing Depth at 2194") + 
  theme_classic()
```

# Cacluate & Visualize community dissimilarity 

Exploratory analyses from Paliy & Shankar (2016) paper, which is using unconstrained ordination methods like PCoA. 

## PCoA 
### Sorensen
```{r sorensen-PCoA}
# Calculate sorensen dissimilarity: Abundance-unweighted of shared taxa
scaled_soren_pcoa <-  
  ordinate(
    physeq = scaled_rooted_physeq,
    method = "PCoA",
    distance = "bray", binary = TRUE)

#str(scaled_soren_pcoa)

# Plot the ordination
n_colors <- as.factor(n_colors)
soren_n_pcoa <- plot_ordination(
  physeq = scaled_rooted_physeq,
  ordination = scaled_soren_pcoa,
  color = as.factor("n_level"),
  title = "Sorensen PCoA") +
  geom_point(size=5, alpha = 0.5, aes(color = as.factor(n_level))) +
  scale_color_manual(values = as.factor(n_colors)) + 
  theme_bw()
# Show the plot 
soren_n_pcoa

# Plot for comparison between planted vs. unplanted status
# Plot the ordination
planted_colors <- as.factor(planted_colors)
soren_planted_pcoa <- plot_ordination(
  physeq = scaled_rooted_physeq,
  ordination = scaled_soren_pcoa,
  color = as.factor("planted"),
  title = "Sorensen PCoA") +
  geom_point(size=5, alpha = 0.5, aes(color = as.factor(planted))) +
  scale_color_manual(values = as.factor(planted_colors)) + 
  theme_bw()
# Show the plot 
soren_planted_pcoa
```
Much clearer presence/absence separation based on planted vs. unplanted status.

### Bray
```{r bray-PCoA}
# Calculate the BC distance
scaled_BC_pcoa <- 
  ordinate(
    physeq = scaled_rooted_physeq,
    method = "PCoA",
    distance = "bray")

# Plot the PCoA
bray_n_pcoa <- plot_ordination(
  physeq = scaled_rooted_physeq,
  ordination = scaled_BC_pcoa,
  color = as.factor("n_level"),
  title = "Bray-Curtis PCoA") +
  geom_point(size=5, alpha = 0.5, aes(color = as.factor(n_level))) +
  scale_color_manual(values = as.factor(n_colors)) + 
  theme_bw()
# Show the plot 
bray_n_pcoa


# Plot for comparison between planted vs. unplanted status
# Plot the PCoA
bray_planted_pcoa <- plot_ordination(
  physeq = scaled_rooted_physeq,
  ordination = scaled_BC_pcoa,
  color = as.factor("planted"),
  title = "Bray-Curtis PCoA") +
  geom_point(size=5, alpha = 0.5, aes(color = as.factor(planted))) +
  scale_color_manual(values = as.factor(planted_colors)) + 
  theme_bw()
# Show the plot 
bray_planted_pcoa
```
More variance can be explained by the axis of the abundance-weighted ordination:
20% for Bray-Curtis vs. only 10.3% for Sorensen ordination. Clear separations based on n-level are not evident, but separations based on plant presence are!

### Weighted Unifrac
```{r wUnifrac-PCoA}
# Calculate the BC distance
scaled_wUNI_pcoa <- 
  ordinate(
    physeq = scaled_rooted_physeq,
    method = "PCoA",
    distance = "wunifrac")

# Plot the PCoA
wUNI_n_pcoa <- 
  plot_ordination(
    physeq = scaled_rooted_physeq,
    ordination = scaled_wUNI_pcoa,
    color = as.factor("n_level"),
    title = "Weighted Unifrac PCoA") +
  geom_point(size=5, alpha = 0.5, aes(color = as.factor(n_level))) +
  scale_color_manual(values = as.factor(n_colors)) + 
  theme_bw()
wUNI_n_pcoa

wUNI_planted_pcoa <- 
  plot_ordination(
    physeq = scaled_rooted_physeq,
    ordination = scaled_wUNI_pcoa,
    color = as.factor("planted"),
    title = "Weighted Unifrac PCoA") +
  geom_point(size=5, alpha = 0.5, aes(color = as.factor(planted))) +
  scale_color_manual(values = as.factor(planted_colors)) + 
  theme_bw()
wUNI_planted_pcoa
```
32.1% variation explained by the Weighted Unifrac PCoA

## Combine PCoAs

#Let's plot all three together into one plot to have a concise visualization of the three metrics. 
```{r pcoa-together, fig.width=8, fig.height=3.5}
(soren_n_pcoa + theme(legend.position = "none")) + 
  (bray_n_pcoa + theme(legend.position = "none")) + 
    (wUNI_n_pcoa + theme(legend.position = "none"))

(soren_planted_pcoa + theme(legend.position = "none")) + 
  (bray_planted_pcoa + theme(legend.position = "none")) + 
    (wUNI_planted_pcoa + theme(legend.position = "none"))
```


## NMDS 

### Weighted Unifrac

Since we did 3 of the dissimilarity metrics for the PCoA, let's just plot one example of them for the NMDS plotting. Here, we will use weighted Unifrac 
```{r wUnifrac-NMDS}
# Calculate the Weighted Unifrac distance
scaled_wUNI_nmds <- 
  ordinate(
    physeq = scaled_rooted_physeq,
    method = "NMDS",
    distance = "wunifrac")

# Plot the PCoA
wUNI_n_nmds <- 
  plot_ordination(
    physeq = scaled_rooted_physeq,
    ordination = scaled_wUNI_nmds,
    color = as.factor("n_level"),
    title = "Weighted Unifrac NMDS") +
  geom_point(size=5, alpha = 0.5, aes(color = as.factor(n_level))) +
  scale_color_manual(values = as.factor(n_colors)) + 
  theme_bw()
wUNI_n_nmds

wUNI_planted_nmds <- 
  plot_ordination(
    physeq = scaled_rooted_physeq,
    ordination = scaled_wUNI_nmds,
    color = as.factor("planted"),
    title = "Weighted Unifrac NMDS") +
  geom_point(size=5, alpha = 0.5, aes(color = as.factor(planted))) +
  scale_color_manual(values = as.factor(planted_colors)) + 
  theme_bw()
wUNI_planted_nmds
```

```{r combined-wUnifrac, fig.width=6, fig.height=3.5}
(wUNI_n_pcoa + theme(legend.position = "none")) + 
  (wUNI_n_nmds + theme(legend.position = "none"))

(wUNI_planted_pcoa + theme(legend.position = "none")) + 
  (wUNI_planted_nmds + theme(legend.position = "none"))
```

# Statistical Significance Testing 

## PERMANOVA 
```{r PERMANOVA}
# Calculate all three of the distance matrices
scaled_sorensen_dist <- phyloseq::distance(scaled_rooted_physeq, method = "bray", binary = TRUE)
scaled_bray_dist <- phyloseq::distance(scaled_rooted_physeq, method = "bray")
scaled_wUnifrac_dist <- phyloseq::distance(scaled_rooted_physeq, method = "wunifrac")

# make a data frame from the sample_data
# All distance matrices will be the same metadata because they 
# originate from the same phyloseq object. 
metadata <- data.frame(sample_data(scaled_rooted_physeq))

# Adonis test
# In this example we are testing the hypothesis that the five stations
# that were collected have different centroids in the ordination space 
# for each of the dissimilarity metrics, we are using a discrete variable 
adonis2(scaled_sorensen_dist ~ n_level, data = metadata)
adonis2(scaled_bray_dist ~ n_level, data = metadata)
adonis2(scaled_wUnifrac_dist ~ n_level, data = metadata)

adonis2(scaled_sorensen_dist ~ planted, data = metadata)
adonis2(scaled_bray_dist ~ planted, data = metadata)
adonis2(scaled_wUnifrac_dist ~ planted, data = metadata)

```
No significant diffrence between nitrogen levels

Differences between planted and unplanted treatments are significant. The most difference is explained by the Weighted Unifrac.

```{r PERMANOVA-multiVariable}
# We might also care about other variables
# Here, we will add date and fraction as variables
# multiplicative model ORDER MATTERS! 
adonis2(scaled_sorensen_dist ~ n_level * growth_stage * planted, data = metadata)
adonis2(scaled_bray_dist ~ n_level * growth_stage * planted, data = metadata)
# Note that the ORDER MATTERS!
adonis2(scaled_wUnifrac_dist ~ n_level * growth_stage * planted, data = metadata)
adonis2(scaled_wUnifrac_dist ~ growth_stage * n_level * planted, data = metadata)
```

## BetaDispR

The PERMANOVA is sensitive to variance/dispersion in the data. Therefore, we need to run a homogeneity of dispersion test to test for the sensitivity of our PERMANOVA results to variance. 
```{r betadispR}
# Homogeneity of Dispersion test with beta dispr
# Sorensen 
beta_soren_n <- betadisper(scaled_sorensen_dist, metadata$n_level)
permutest(beta_soren_n)

beta_soren_planted <- betadisper(scaled_sorensen_dist, metadata$planted)
permutest(beta_soren_planted)

# Bray-curtis 
beta_bray_n <- betadisper(scaled_bray_dist, metadata$n_level)
permutest(beta_bray_n)

beta_bray_planted <- betadisper(scaled_bray_dist, metadata$planted)
permutest(beta_bray_planted)

# Weighted Unifrac 
beta_bray_n <- betadisper(scaled_wUnifrac_dist, metadata$n_level)
permutest(beta_bray_n)

beta_bray_planted <- betadisper(scaled_wUnifrac_dist, metadata$planted)
permutest(beta_bray_planted)
```

Variance of Sorensen influenced by nitrogen level.

# Taxonomic Composition

## Phylum
```{r phylum-colors}
# Set the phylum colors
phylum_colors <- c(
  Acidobacteriota = "navy", 
  Firmacutes = "darkslategray2", 
  Armatimonadota = "deeppink1",
  Alphaproteobacteria = "plum2", 
  Bacteroidota = "gold", 
  Betaproteobacteria = "plum1", 
  Bdellovibrionota = "red1",
  Chloroflexi="black", 
  Crenarchaeota = "firebrick",
  Cyanobacteria = "limegreen",
  Deltaproteobacteria = "grey", 
  Desulfobacterota="magenta",
  Firmicutes = "#3E9B96",
  Gammaproteobacteria = "greenyellow",
  "Marinimicrobia (SAR406 clade)" = "yellow",
  Myxococcota = "#B5D6AA",
  Nitrospirota = "palevioletred1",
  Proteobacteria = "royalblue",
  Planctomycetota = "darkorange", 
  "SAR324 clade(Marine group B)" = "olivedrab",
  #Proteobacteria_unclassified = "greenyellow",
  Thermoplasmatota = "green",
  Verrucomicrobiota = "darkorchid1")
 # Other = "grey")
```


```{r phylum-composition}
# Calculate the phylum relative abundance 
# Note: The read depth MUST be normalized in some way: scale_reads
phylum_df <- 
  scaled_rooted_physeq %>%
  # agglomerate at the phylum level 
  tax_glom(taxrank = "Phylum") %>% 
  # Transform counts to relative abundance 
  transform_sample_counts(function (x) {x/sum(x)}) %>%
  # Melt to a long format 
  psmelt() %>%
  # Filter out Phyla that are <1% - get rid of low abundant Phyla
  dplyr::filter(Abundance > 0.01)
```

```{r phylum-plot, fig.width=8, fig.height=9}


phylum_df %>%
  # Warning: It's important to have one sample per x value, 
  # otherwise, it will take the sum between multiple samples
  ggplot(aes(x = planted, y = Abundance, fill = Phylum)) + 
  facet_grid(Phylum~growth_stage~n_level, scale = "free") + 
  geom_bar(stat = "identity", color = "black") + 
  labs(title = "Surface Phylum Composition") + 
  scale_fill_manual(values = phylum_colors) + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1),
        strip.text.y = element_text(size = 5))
```

```{r phylum-station-firmicutes, fig.width=5, fig.height=3.5}
# Narrow in on a specific group
# Firmacutes - y: abundance, x: station, dot plot + boxplot
phylum_df %>%
  dplyr::filter(Phylum == "Firmicutes") %>%
  # build the plot 
  ggplot(aes(x = as.factor(planted), y = Abundance, 
             fill = as.factor(planted), color = as.factor(planted))) + 
  facet_wrap(.~Phylum, scales = "free_y", nrow = 1) + 
  geom_boxplot(alpha = 0.5, outlier.shape = NA) + # outliers not plotted here in boxplot 
  geom_jitter() + 
  theme_bw() + 
  labs(title = "Firmicutes Phylum Abundance") + 
  scale_color_manual(values = as.factor(planted_colors)) + 
  scale_fill_manual(values = as.factor(planted_colors)) + 
    theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1),
          legend.position = "right")
# Statistically: Kruskall-Wallis followed by a Tukey's Posthoc test
# These are non-parametric (non-normal) stat tests 
```

## Family
```{r family-composition, fig.width=10, fig.height=4}
# Calculate the Family relative abundance 
# Note: The read depth MUST be normalized in some way: scale_reads
family_df <- 
  scaled_rooted_physeq %>%
  # agglomerate at the phylum level 
  tax_glom(taxrank = "Family") %>% 
  # Transform counts to relative abundance 
  transform_sample_counts(function (x) {x/sum(x)}) %>%
  # Melt to a long format 
  psmelt() %>%
  # Filter out Phyla that are <1% - get rid of low abundant Phyla
  dplyr::filter(Abundance > 0.01)
  
  # Check family_df
#str(family_df)

family_df %>%
  dplyr::filter(Phylum == "Firmicutes") %>%
  # build the plot 
  ggplot(aes(x = as.factor(planted), y = Abundance, 
             fill = as.factor(planted), color = as.factor(planted))) + 
  facet_wrap(.~Family, scales = "free_y", nrow = 1) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) + # outliers not plotted here in boxplot 
  geom_jitter() + 
  theme_bw() + 
  labs(title = "Firmicutes Family Abundance") + 
  scale_color_manual(values = as.factor(planted_colors)) + 
  scale_fill_manual(values = as.factor(planted_colors)) + 
    theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1),
          legend.position = "bottom")
```

## Genus
```{r genus-plots, fig.width=12, fig.height=4}
# Calculate the Family relative abundance 
# Note: The read depth MUST be normalized in some way: scale_reads
genus_df <- 
  scaled_rooted_physeq %>%
  # agglomerate at the phylum level 
  tax_glom(taxrank = "Genus") %>% 
  # Transform counts to relative abundance 
  transform_sample_counts(function (x) {x/sum(x)}) %>%
  # Melt to a long format 
  psmelt() %>%
  # Filter out Phyla that are <1% - get rid of low abundant Phyla
  dplyr::filter(Abundance > 0.01)

genus_df %>%
  dplyr::filter(Phylum == "Firmicutes") %>%
  # build the plot 
  ggplot(aes(x = as.factor(planted), y = Abundance, 
             fill = as.factor(planted), color = as.factor(planted))) + 
  facet_wrap(.~Genus, scales = "free_y", nrow = 1) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) + # outliers not plotted here in boxplot 
  geom_jitter() + 
  theme_bw() + 
  labs(title = "Firmicutes Family Abundance") + 
  scale_color_manual(values = as.factor(planted_colors)) + 
  scale_fill_manual(values = as.factor(planted_colors)) + 
    theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1),
          legend.position = "bottom")

```


# Session Information 
For reproducibility 
```{r session_info}
devtools::session_info()
```
